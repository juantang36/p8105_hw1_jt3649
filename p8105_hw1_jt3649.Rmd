---
title: "p8105_hw1_jt3649"
author: "Juan Tang"
date: "2025-09-20"
output: github_document
---
## Problem 1
```{r}
library(moderndive)
library(tidyverse)
data("early_january_weather")
```

### Dataset Description
The `early_january_weather` dataset has `r nrow(early_january_weather)` rows (observations) and 
`r ncol(early_january_weather)` columns (variables).

The variables in this dataset are: `r paste(names(early_january_weather), collapse = ", ")`.

The mean temperature across all observations is `r mean(pull(early_january_weather, "temp"), na.rm = TRUE)` ºF.

### Scatterplot of temp vs time_hour
Code for Scatterplot
```{r}
ggplot(early_january_weather,
       aes(x = time_hour, 
           y = temp, 
           color = humid
       )) + geom_point() + labs(title = "Temperature vs. Time Scatterplot", 
             x = "Time(Hour)", 
             y = "Temperature (ºF)", 
             color = "Humidity (%)")
```
Saving the plot
```{r}
ggsave("temperature_vs_time_hour_Scatterplot.png", width = 8, height = 6)
```

### Description of Scatterplot
The scatterplot shows how temperature in New York changed during the first two weeks of January 2013, with x-axis representing time, y-axis representing temperature in ºF, and point color representing humidity. 
The pattern shows a regular daily fluctuation in temperature, presenting a consistent wave-like pattern.The temperature rises during daylight hours and falls at night. Across the two-week period, there appears to be a general upward trend in temperatures, with later days showing higher temperatures overall compared to the beginning of the period. Around January 14, there is a noticeable peak where the temperature exceeded 56°F.

There is an inverse relationship between temperature and humidity in general although the relationship is not strictly linear. Higher temperatures are shown to correspond with lower humidity levels (darker color) and lower temperatures correspond with higher humidity levels (lighter colored points). 


## Problem 2
Creating a dataframe
```{r}
df=tibble(
  random_sample = rnorm(10), 
  logical_vec = random_sample > 0, 
  char_vec = letters[1:10], 
  factor_vec = factor(rep(c("low", "medium", "high"), 
                          length.out = 10),
                      levels = c("low", "medium", "high"))
)
```
This is the dataframe for problem 2: 
```{r}
df
```
Take the mean of each variable in the dataframe df
```{r}
#valid output for numeric variable
mean_random_sample = mean(pull(df, "random_sample")) 
cat("Mean of random sample variable =", mean_random_sample)
#valid output for logical variable
mean_logical_vec = mean(pull(df, "logical_vec"))
cat("Mean of logical vector =", mean_logical_vec)
#invalid output for character variable
mean_char_vec = mean(pull(df, "char_vec"))
#invalid output for factor variable
mean_factor_vec = mean(pull(df, "factor_vec"))
```

### Explanation
The mean of random_sample is `r mean(pull(df, "random_sample"))`. This mean works because it's numeric value. 
The mean of logical_vec is `r mean(pull(df, "logical_vec"))`. This mean also works because logical values are coerced to 0 (False) or 1 (TRUE). When a mean is requested, the system automatically convert each TRUE to a 1 and each FALSE to a 0. It then adds up all the 1s and 0s, and devides the sum by the total number of values in the list. 
char_vec and factor_vec cannot take mean values because they are text and categorical labels. 

### as.numeric Function
```{r, eval=FALSE}
as.numeric(pull(df, "random_sample")) 
as.numeric(pull(df, "logical_vec"))
as.numeric(pull(df, "factor_vec"))
```
### Explanation (as.numeric function)
The as.numeric function converts logical variables to numeric numbers. "as.numeric(pull(df, "logical_vec"))" defines TRUE = 1 and FALSE = 0. The mean therefore represents the proportion of TRUE values. 
Factor vectors can be coerces to numeric, but they are converted to the internal integer codes of the level (eg. low = 1, medium = 2, high = 3). In this case, the mean can be computed. 
The function fails to convert characters (string) to numeric, the output is "NA". Mean cannot be taken for characters because characters cannot be meaningfully converted into numbers.
Hence, mean() function works for numeric and logical variables, and fails for character and factor. But if we use as.numeric to convert factors to numeric numbers, mean can still be taken. 